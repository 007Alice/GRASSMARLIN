package TemplateEngine.Template4;

import TemplateEngine.Template4.SourceTemplate.MasterTemplate;
import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.gui.STViz;

import java.io.FileWriter;
import java.io.IOException;

/**
 * @author BESTDOG
 *         <p>
 *         Interface used by all Template4, allowing for easy of manipulating {@link ST} and
 *         structuring and generating java source code.
 */
public interface Template {
    /**
     * Master template all templates will load its ST4 template from by its {@link #getName()} value.
     */
    static final MasterTemplate MASTER_TEMPLATE = new MasterTemplate();

    public static ST get(String name) {
        return MASTER_TEMPLATE.getInstanceOf(name);
    }

    /**
     * Converts Strings to valid java Identifiers by replacing illegal characters with underscores.
     *
     * @param s String to convert.
     * @return Valid javaIdentifier, "$0" if provided string is empty.
     */
    public static String asJavaIdentifier(String s) {
        if (s.isEmpty()) return "$0";
        StringBuilder b = new StringBuilder();
        if (!s.startsWith("$")) {
            b.append("$");
            for (char c : s.toCharArray())
                if (Character.isJavaIdentifierPart(c))
                    b.append(c);
                else
                    b.append("_");

        } else {
            b.append(s);
        }
        return b.toString();
    }

    default ST get() {
        return get(this.getName());
    }

    /**
     * @return The source code generated by this template, assuming all parameters are set properly.
     */
    default String render() {
        ST st = get();
        this.render(st);
        return st.render();
    }

    /**
     * @param fw Writer which will have the {@link #render()} methods value supplier to the {@link FileWriter#write(String)} method.
     * @throws IOException Thrown on failure to write or flush FileWriter.
     */
    default void renderToFile(FileWriter fw) throws IOException {
        fw.write(render());
        fw.flush();
    }

    /**
     * Opens the ST visualizer for debugging purposes.
     *
     * @param st         ST to visualize.
     * @param title      Title for the Visualization's window.
     * @param setVisible True to show, false does nothin.
     */
    default void visualize(ST st, String title, boolean setVisible) {
        if (setVisible) {
            STViz viz = st.inspect();
            viz.viewFrame.setTitle(title);
            viz.viewFrame.setVisible(true);
        }
    }

    /**
     * Gets the name for the template within the template group file which is associated with this class.
     *
     * @return Name for this template.
     */
    String getName();

    /**
     * Gets the raw template ST code from the .st or .stg file.
     *
     * @return raw ST code.
     */
    String getTemplate();

    /**
     * Sets ST code for this template to use.
     *
     * @param template ST4 code.
     */
    void setTemplate(String template);

    /**
     * Renders the ST template by the parameters within this class.
     *
     * @param st ST to add properties to.
     */
    void render(ST st);

    /**
     * Retrieves the parent of this Template4.
     *
     * @return Parent of this template, else null if not present.
     */
    Template getParent();

    /**
     * Sets the parent template this template resides within, much like nested source code.
     *
     * @param parent Parent containing this template.
     */
    void setParent(Template parent);

    /**
     * Returns the value of {@link #getScopeName()} of the {@link #getParent()}.
     * Meant to allow source code to reference its own or a parent named scope.
     *
     * @return Named scope of the parent Template4.
     */
    default String getScopeName() {
        return getParent().getScopeName();
    }

}
