package sample;

import core.fingerprint.*;
import core.ui.graph.ContainerNode;
import core.ui.graph.DefaultNode;
import core.ui.graph.RoundedTextNode;
import core.ui.graph.SimpleTextNode;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.embed.swing.SwingNode;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.control.Button;
import javafx.scene.control.Dialog;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.layout.*;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.stage.WindowEvent;
import javafx.util.Duration;

import javax.swing.*;
import javax.xml.bind.JAXBException;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Controller class for the fingerprint manager gui
 */
public class Controller implements Initializable {
    /** Text to display on a filtergroup element  */
    public final static String FILTER_GROUP_CONTAINER_LABEL_TEXT = "Filter Group";
    /** internal identifier */
    public final static String FILTER_GROUP_CONTAINER_IDENTIFIER = "filtergroup";
    /** Name field from the gui */
    @FXML
    public TextField textFieldNameId;
    /** Author field from the gui */
    @FXML
    public TextField textFieldAuthorId;
    /** Tags field from the gui */
    @FXML
    public TextField textFieldTagsId;
    /** Description Field from the gui */
    @FXML
    public TextField textFieldDescriptionId;
    /** this is the container for all the tabs */
    @FXML
    public TabPane payloadTabsId;
    @FXML
    public ScrollPane filterButtonScrollPaneId;
    /** the pane where the buttons are */
    @FXML
    private GridPane filterAdderPane;
    /** list of tabs */
    private ArrayList<Tab> tabList;
    /** The swing node panels */
    private ArrayList<FpPanel> filterPanelList;
    /** the treeview panels */
    private ArrayList<TreeView<XmlElementTreeItem>> treeViewPanelList;
    /** the currently focused tab index */
    private int focusTab = 0;
    /** Font color for fingerprint group */
    private static final Color GROUP_FONT_COLOR = new Color(206,213,231);
    /** font color for filters */
    private static final Color FILTER_FONT_COLOR = new Color(47,65,114);
    /** Background color for filters */
    private static final Color FILTER_COLOR = new Color(206,213,231);
    /** background color for group, light */
    private static final Color GROUP_LIGHT_COLOR = new Color(47,65,114);
    /** background color for group, dark */
    private static final Color GROUP_DARK_COLOR = new Color(6,20,57);
    /** a refference to the primary stage (set by main) ((used for filechooser)) */
    private Stage stage;
    /** the folder to open to when loading or saving a file (set by param) */
    private File defaultFingerprintFolder;
    /** the argument name for containing the path to fingerprints */
    private static final String DEFAULT_PATH_ARGUMENT_NAME = "path";
    /** the argument name for containing the path to fingerprints */
    private static final String LOAD_FILE_ON_OPEN_ARGUMENT_NAME = "loadFile";
    /** global flag for warnign user about save status */
    private boolean notSaved = false;
    /** Changes dialog */
    private Changes changesDialog = new Changes();

    /**
     * initializes the user interface
     * this is called by the loader automatically once the FXML is read in
     * @param location
     * @param resources
     */
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        addListeners();
        this.payloadTabsId.setTabClosingPolicy(TabPane.TabClosingPolicy.SELECTED_TAB);
        //create the first payload tab
        createNewPayloadTab();
        ArrayList<Node> buttonWithLabelsList = createButtonsWithLabels();
        VBox vbButtons = new VBox();
        vbButtons.setSpacing(10);
        vbButtons.setPadding(new Insets(0, 20, 10, 20));
        vbButtons.getChildren().addAll(buttonWithLabelsList);
        filterAdderPane.add(vbButtons, 1, 3);

    }

    @FXML
    public void displayChanges() {
        changesDialog.showAndWait();
    }

    /**
     * adds some listeners to elements generated by the FXML
     */
    private void addListeners() {
        this.payloadTabsId.getSelectionModel().selectedItemProperty().addListener((observableView, tab, tab2) -> {
            if (tab2 != null) {
                String tabName = tab2.getText();
                tabName = tab2.getText().replace("OR ", "");
                tabName = tabName.replace("Payload ", "");
                Controller.this.focusTab = (Integer.parseInt(tabName) - 1);
            }
        });
        this.textFieldNameId.textProperty().addListener((observable, oldValue, newValue) -> this.setNotSaved());
        this.textFieldAuthorId.textProperty().addListener((observable, oldValue, newValue) -> this.setNotSaved());
        this.textFieldTagsId.textProperty().addListener((observable, oldValue, newValue) -> this.setNotSaved());
        this.textFieldDescriptionId.textProperty().addListener((observable, oldValue, newValue) -> this.setNotSaved());
    }

    /**
     * Creates a list of buttons for each Filter type element
     * @return
     */
    private ArrayList<Node> createButtonsWithLabels() {
        ArrayList<Node> buttonWithLabelsList = new ArrayList<>();
        Arrays.asList(FingerprintFilterType.PacketType.values()).stream().forEach(packetType -> {
            buttonWithLabelsList.add(new Label(packetType.name() + ":"));
            buttonWithLabelsList.addAll(
                    Arrays.asList(FingerprintFilterType.values()).stream()
                            .filter(fingerprintFilterType -> fingerprintFilterType.getType() == packetType)
                            .map(fingerprintFilterType -> {
                                Button button = fingerprintFilterType.getButton(this);
                                Tooltip tooltip = new Tooltip(fingerprintFilterType.getToolTip());
                                hackToolTipDelay(tooltip);
                                button.setTooltip(tooltip);
                                return button;
                            }).collect(Collectors.toList()));
        });
        return buttonWithLabelsList;
    }

    /**
     * Sets the saved status
     */
    public void setNotSaved() {
        if(this.stage != null) {
            if (!this.notSaved) {
                this.notSaved = true;
                this.stage.setTitle(this.stage.getTitle() + " (NOT SAVED)");
            }
        }
    }

    /**
     * sets the save status
     */
    public void setSaved() {
        if(this.stage != null) {
            if (this.notSaved) {
                this.notSaved = false;
                this.stage.setTitle(this.stage.getTitle().replace(" (NOT SAVED)", ""));
            }
        }
    }

    /**
     * Creates a pop-out description dialog
     */
    @FXML
    public void popOutDescription() {
        String descriptionText = this.textFieldDescriptionId.getText().replace("<br/>","\n");

        Dialog<String> descriptionDialog = new Dialog<>();
        descriptionDialog.setTitle("Description");
        descriptionDialog.setHeaderText("Description Text");

        Label label = new Label("Description: ");
        TextArea textArea = new TextArea(descriptionText);
        textArea.setEditable(true);
        textArea.setWrapText(true);
        textArea.setMaxWidth(Double.MAX_VALUE);
        textArea.setMaxHeight(Double.MAX_VALUE);
        GridPane.setVgrow(textArea, Priority.ALWAYS);
        GridPane.setHgrow(textArea, Priority.ALWAYS);

        GridPane expContent = new GridPane();
        expContent.setMaxWidth(Double.MAX_VALUE);
        expContent.add(label, 0, 0);
        expContent.add(textArea,0,1);
        descriptionDialog.getDialogPane().setContent(expContent);

        descriptionDialog.getDialogPane().getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);

        descriptionDialog.setResultConverter(dialogButton -> {
            if (dialogButton == ButtonType.OK) {
                return textArea.getText();
            }
            return null;
        });

        descriptionDialog.showAndWait().ifPresent(s -> this.textFieldDescriptionId.setText(s.replace("\n", "<br/>")));
    }

    /**
     * handles the arguments the applicationw as lauinched with (called from main)
     * @param namedArgMap
     */
    public void setArgs(Map<String, String> namedArgMap) {
        if(namedArgMap.containsKey(DEFAULT_PATH_ARGUMENT_NAME)) {
            this.defaultFingerprintFolder = new File(namedArgMap.get(DEFAULT_PATH_ARGUMENT_NAME));
        }
        else {
            this.defaultFingerprintFolder = new File("C:\\home");
        }
        if(!validateFolder(this.defaultFingerprintFolder)) {
            System.err.println("Error accessing default FP folder: " + this.defaultFingerprintFolder.getAbsolutePath());
            this.defaultFingerprintFolder = null;
        }
        if(namedArgMap.containsKey(LOAD_FILE_ON_OPEN_ARGUMENT_NAME)) {
            File fileToLoad = new File(namedArgMap.get(LOAD_FILE_ON_OPEN_ARGUMENT_NAME));
            if(fileToLoad.exists() && fileToLoad.canRead()) {
                loadFile(fileToLoad);
            }
        }
    }

    /**
     * simple method to validate a folder
     * @param defaultFingerprintFolder
     * @return
     */
    private boolean validateFolder(File defaultFingerprintFolder) {
        return defaultFingerprintFolder.exists() && defaultFingerprintFolder.canRead() && defaultFingerprintFolder.canWrite();
    }

    /**
     * The only way to set the tooltip delay currently is to reflectively hack it
     * @param tooltip
     */
    private void hackToolTipDelay(Tooltip tooltip) {
        try {
            Field fieldBehavior = tooltip.getClass().getDeclaredField("BEHAVIOR");
            fieldBehavior.setAccessible(true);
            Object objBehavior = fieldBehavior.get(tooltip);

            Field fieldTimer = objBehavior.getClass().getDeclaredField("activationTimer");
            fieldTimer.setAccessible(true);
            Timeline objTimer = (Timeline) fieldTimer.get(objBehavior);

            objTimer.getKeyFrames().clear();
            objTimer.getKeyFrames().add(new KeyFrame(new Duration(100)));
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * simply adds a filter item to the active tab filterpane
     * @param name
     * @param value
     */
    public void addFilterToActiveTab(String name, String value) {
        setNotSaved();
        RoundedTextNode newNode = createFilterNode(name, value);
        this.filterPanelList.get(this.focusTab).addNode(newNode);
        this.filterPanelList.get(this.focusTab).resize();
    }

    /**
     * Easy way to set a pane to fill entire space of parent
     * @param node
     */
    private void setAnchorPaneAnchors(javafx.scene.Node node) {
        AnchorPane.setBottomAnchor(node, 0.0);
        AnchorPane.setTopAnchor(node, 0.0);
        AnchorPane.setLeftAnchor(node, 0.0);
        AnchorPane.setRightAnchor(node, 0.0);
    }

    /**
     * initialize lists for tabs in needed.
     */
    private void initializeLists() {
        if(this.filterPanelList == null) {
            this.filterPanelList = new ArrayList<>();
        }
        if(treeViewPanelList == null) {
            this.treeViewPanelList = new ArrayList<>();
        }
        if(this.tabList == null) {
            this.tabList = new ArrayList<>();
        }
    }

    /**
     * Loads a new fingerprint file
     */
    @FXML
    public void loadFile() {
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
        alert.setTitle("WARNING");
        alert.setHeaderText("You are about to load a new Fingerprint file, the fingerprint you are\ncurrently viewing will be closed and any unsaved changed will be lost.");
        alert.setContentText("Do you wish to proceed?");

        Optional<ButtonType> result = alert.showAndWait();
        if (result.get() == ButtonType.OK) {
            FileChooser fc = new FileChooser();
            fc.setTitle("Load a Fingerprint");
            if(this.defaultFingerprintFolder != null) {
                fc.setInitialDirectory(this.defaultFingerprintFolder);
            }
            fc.getExtensionFilters().add(new FileChooser.ExtensionFilter("Fingerprint", "*.xml"));
            File file = fc.showOpenDialog(this.stage);
            if(file != null) {
                this.defaultFingerprintFolder = file.getParentFile();
                loadFile(file);
            }
        }
    }

    private void loadFile(File file) {
        try {
            clear();
            FingerprintReader reader = new FingerprintReader();
            reader.loadFile(file, this);
            //resets changes flag
            setSaved();
        } catch (JAXBException e) {
            e.printStackTrace();
        }
    }

    /**
     * Clears the application
     */
    @FXML
    public void newFingerprint() {
        if(this.notSaved) {
            Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
            alert.setTitle("WARNING");
            alert.setHeaderText("You are about to create a new Fingerprint, the fingerprint you are\ncurrently viewing will be closed and any unsaved changed will be lost.");
            alert.setContentText("Do you wish to proceed?");

            Optional<ButtonType> result = alert.showAndWait();
            if (result.get() == ButtonType.OK) {
                clear();
                createNewPayloadTab();
                //resets changes flag
                setSaved();
            }
        }
        else {
            clear();
            createNewPayloadTab();
            //resets changes flag
            setSaved();
        }
    }

    /**
     * saves the displayed fingerprint to a file
     * @return
     */
    @FXML
    public boolean saveAs() {
        boolean isSaved = false;
        if(validateForm()) {
            FileChooser fc = new FileChooser();
            fc.setTitle("Choose where to save fingerprint");
            if(this.defaultFingerprintFolder != null) {
                fc.setInitialDirectory(this.defaultFingerprintFolder);
            }
            fc.setInitialFileName(this.textFieldNameId.getText() + ".xml");
            File file = fc.showSaveDialog(this.stage);

            if(file!=null) {
                this.defaultFingerprintFolder = file.getParentFile();
                FingerprintBuilder fpBuilder = new FingerprintBuilder(
                        this.textFieldNameId.getText(),
                        this.textFieldAuthorId.getText(),
                        this.textFieldDescriptionId.getText(),
                        this.textFieldTagsId.getText());
                try {
                    fpBuilder.processFilterPanel(this.filterPanelList, this);
                    fpBuilder.processPayloadPanel(this.treeViewPanelList, this);
                    fpBuilder.saveFile(file);
                    setSaved();
                    isSaved = true;
                } catch (IOException | JAXBException e) {
                    showException(e);
                }
            }
        }
        return isSaved;
    }

    /**
     * shows an exception dialog (convenience method)
     * @param e
     */
    public void showException(Exception e) {
        showException(e.getMessage(),e);
    }

    /**
     * Shows and exception dialog
     * @param message
     * @param e
     */
    public void showException(String message, Exception e) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText("Error taking action");
        alert.setContentText(message);

        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);

        String exceptionText = sw.toString();
        Label label = new Label("Exception: ");
        TextArea textArea = new TextArea(exceptionText);
        textArea.setEditable(false);
        textArea.setWrapText(true);
        textArea.setMaxWidth(Double.MAX_VALUE);
        textArea.setMaxHeight(Double.MAX_VALUE);
        GridPane.setVgrow(textArea, Priority.ALWAYS);
        GridPane.setHgrow(textArea, Priority.ALWAYS);

        GridPane expContent = new GridPane();
        expContent.setMaxWidth(Double.MAX_VALUE);
        expContent.add(label,0,0);
        expContent.add(textArea,0,1);

        alert.getDialogPane().setExpandableContent(expContent);

        alert.showAndWait();
    }

    /**
     * validates the application before saving
     *
     * @return
     */
    private boolean validateForm() {
        ArrayList<String> errorMessages = new ArrayList<>();
        boolean valid = true;
        if(this.textFieldAuthorId.getText().isEmpty()) {
            errorMessages.add("Author must be set!");
            valid = false;
        }
        if(this.textFieldNameId.getText().isEmpty()) {
            errorMessages.add("Fingerprint Name must be set!");
            valid = false;
        }
        if(!valid) {
            displayError(errorMessages);
        }
        return valid;
    }

    /**
     * displays an error popup
     * @param errorMessages
     */
    private void displayError(ArrayList<String> errorMessages) {
        StringBuilder errors = new StringBuilder();
        errorMessages.stream().forEach(s -> errors.append((errors.length() == 0) ? s : "\n" + s));
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error Saving");
        alert.setHeaderText("Unable to Save");
        alert.setContentText(errors.toString());
        alert.showAndWait();
    }

    /**
     * creates a new fingerprint panel from scratch (new uuid)
     * @param fingerprintPanelList
     * @return
     */
    public AnchorPane createFingerPrintPanel(ArrayList<FpPanel> fingerprintPanelList) {
        return createFingerPrintPanel(fingerprintPanelList, null);
    }

    /**
     * creates a fingerprint panel with given uuid
     * @param fingerprintPanelList
     * @param uuid
     * @return
     */
    public AnchorPane createFingerPrintPanel(ArrayList<FpPanel> fingerprintPanelList, String uuid) {
        StackPane swingNodeContainer = new StackPane();
        FpPanel newPanel;
        if(uuid == null) {
            newPanel = new FpPanel(swingNodeContainer);
        }
        else {
            newPanel = new FpPanel(swingNodeContainer, uuid);
        }
        newPanel.setSize(800, 600);
        newPanel.setController(this);
        fingerprintPanelList.add(newPanel);
        //stack pane where the filter panel exists
        ScrollPane scrollPane = new ScrollPane();
        //bottom of the split pane (payload)
        AnchorPane anchorPane = new AnchorPane(scrollPane);
        setAnchorPaneAnchors(scrollPane);
        SwingNode newSwingNode = new SwingNode();
        //This is the key part that makes the swing stuff from the FPpanel work
        swingNodeContainer.getChildren().add(newSwingNode);
        SwingUtilities.invokeLater(() -> newSwingNode.setContent(newPanel));
        scrollPane.setContent(swingNodeContainer);
        return anchorPane;
    }

    /**
     * creates the treeview panel with given uuid
     * @param id
     * @return
     */
    public AnchorPane createTreeViewPanel(String id) {
        XmlElementTreeItem rootItem = new XmlElementTreeItem(Instruction.PAYLOAD);
        rootItem.setHelpText("Right click to add, Double-click to edit");
        rootItem.addAttribute(new XmlElementAttribute("ID"), id);
        TreeView<XmlElementTreeItem> payloadTree = new TreeView<>(new TreeItem<>(rootItem));
        //payloadTree.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> this.setNotSaved());
        payloadTree.getRoot().setExpanded(true);
        payloadTree.setCellFactory(param -> new XmlElementTreeCell(this, payloadTree));
        payloadTree.setOnMouseClicked(event -> {
            if (event.getClickCount() == 2) {
                TreeItem<XmlElementTreeItem> itemClicked = payloadTree.getSelectionModel().getSelectedItem();
                if (itemClicked != payloadTree.getRoot()) {
                    XmlElementTreeItem item = itemClicked.getValue().getInstruction().collectInformationFromUser(itemClicked);
                    if (item != null) {
                        itemClicked.setValue(item);
                        setNotSaved();
                    }
                }
            }
        });
        this.treeViewPanelList.add(payloadTree);
        AnchorPane payLoadTreeAnchor = new AnchorPane(payloadTree);
        setAnchorPaneAnchors(payloadTree);
        return payLoadTreeAnchor;
    }

    /**
     * Creates a new tab
     * @param contentAnchorPane
     * @param numberOfTabs
     * @return
     */
    private Tab createNewTab(AnchorPane contentAnchorPane,int numberOfTabs) {
        //now create the tab pane and add the anchor pane to it that contains the split pane that contains the...
        String tabNamePrefix = "Payload ";
        if(numberOfTabs > 1) {
            tabNamePrefix = "OR " + tabNamePrefix;
        }
        Tab newTab = new Tab(tabNamePrefix +(this.filterPanelList.size()) );
        this.tabList.add(newTab);
        if(this.filterPanelList.size() == 1) {
            newTab.setClosable(false);
        }
        else {
            newTab.setClosable(true);
        }
        newTab.setContent(contentAnchorPane);
        newTab.setOnClosed(event -> {
            int closedIndex = Controller.this.focusTab + 1;
            Controller.this.filterPanelList.remove(closedIndex);
            Controller.this.treeViewPanelList.remove(closedIndex);
            Controller.this.tabList.remove(closedIndex);
            for (int i = 1; i < Controller.this.tabList.size(); i++) {
                Tab workingTab = Controller.this.tabList.get(i);
                workingTab.setText("OR Payload " + (i + 1));

            }
        });
        return newTab;
    }


    /**
     * Creates an entirtely new payload tab complete with filterpane and payload pane
     *
     * Trigged buy click on new tab button (and on initialize)
     */
    @FXML
    public void createNewPayloadTab() {
        setNotSaved();
        initializeLists();
        //split pane to live inside the tabPane
        AnchorPane topPane = createFingerPrintPanel(this.filterPanelList);
        //get the last filterPanelUuid
        String id = this.filterPanelList.get(this.filterPanelList.size()-1).getUuid();
        AnchorPane buttonPane = createTreeViewPanel(id);
        SplitPane newSplitPane = new SplitPane(topPane,buttonPane);
        int tabNumber = this.filterPanelList.size();
        newSplitPane.setOrientation(Orientation.VERTICAL);
        //we add the split pane to the anchor pane because schene builder does it
        AnchorPane tabAnchorPane = new AnchorPane(newSplitPane);
        setAnchorPaneAnchors(newSplitPane);
        //add the tab pane to the tab pane container here
        this.payloadTabsId.getTabs().add(createNewTab(tabAnchorPane, tabNumber));
        addNewReturnGroup(Controller.FILTER_GROUP_CONTAINER_LABEL_TEXT, Controller.FILTER_GROUP_CONTAINER_IDENTIFIER, this.filterPanelList.get(this.filterPanelList.size() - 1), false);
    }

    /**
     * called when loading from file
     * @param uuid
     */
    public void loadNewPayLoadTab(String uuid) {
        initializeLists();
        //split pane to live inside the tabPane
        AnchorPane topPane = createFingerPrintPanel(this.filterPanelList, uuid);
        AnchorPane buttonPane = createTreeViewPanel(uuid);
        SplitPane newSplitPane = new SplitPane(topPane,buttonPane);
        int tabNumber = this.filterPanelList.size();
        newSplitPane.setOrientation(Orientation.VERTICAL);
        //we add the split pane to the anchor pane because schene builder does it
        AnchorPane tabAnchorPane = new AnchorPane(newSplitPane);
        setAnchorPaneAnchors(newSplitPane);
        //add the tab pane to the tab pane container here
        this.payloadTabsId.getTabs().add(createNewTab(tabAnchorPane, tabNumber));
    }

    /**
     * clears the app
     */
    public void clear() {
        if(this.filterPanelList != null) {
            this.filterPanelList.clear();
        }
        if(this.tabList != null) {
            this.tabList.clear();
        }
        if(this.treeViewPanelList != null) {
            this.treeViewPanelList.clear();
        }
        this.textFieldNameId.setText("");
        this.textFieldDescriptionId.setText("");
        this.textFieldAuthorId.setText("");
        this.textFieldTagsId.setText("");
        this.payloadTabsId.getTabs().clear();
    }

    /**
     * creates the physical filter node
     * @param filterName
     * @param value
     * @return
     */
    public RoundedTextNode createFilterNode(String filterName,String value) {
        RoundedTextNode newNode = new RoundedTextNode(125, 45, new Point(10, 280), filterName);
        newNode.setTextLine2(value);
        newNode.setIsCloseable(true);
        newNode.setBorder(2);
        newNode.setBackgroundColor(FILTER_COLOR);
        newNode.setFontColor(FILTER_FONT_COLOR);
        newNode.setMovable(true);
        return newNode;
    }

    /**
     * used for calculating the coords of the next filter group placement
     * @param nodes
     * @param nameFilter
     * @return
     */
    private int getNextXCoord(Collection<DefaultNode> nodes,String nameFilter) {
        int x = 5;
        try {
            x = nodes.stream()
                    .filter(node -> node.getName().equals(nameFilter))
                    .map(node -> node.getNodePointValue(DefaultNode.NodePoint.topRight).x).max(Integer::compare).get();
        }catch(NoSuchElementException e) {
            //this error is ok, means theres no Filter groups yet
        }
        //add padding
        if(x != 5) {
            x += 10;
        }
        return x;
    }

    @FXML
    public ContainerNode addNewFilterGroup() {
        return addNewReturnGroup(
                Controller.FILTER_GROUP_CONTAINER_LABEL_TEXT,
                Controller.FILTER_GROUP_CONTAINER_IDENTIFIER,
                this.filterPanelList.get(this.focusTab),
                false
        );
    }

    /**
     * creates a new filter group
     * @param labelText
     * @param identifier
     * @param targetPanel
     * @param moveable
     * @return
     */
    public ContainerNode addNewReturnGroup(String labelText, String identifier, FpPanel targetPanel, boolean moveable) {
        setNotSaved();
        int x = getNextXCoord(targetPanel.getNodes(), identifier);
        SimpleTextNode text = new SimpleTextNode(125, 25, new Point(0, 0), labelText);
        text.setFontColor(Controller.GROUP_FONT_COLOR);
        Collection<DefaultNode> subNodes = new ArrayList<>();
        subNodes.add(text);
        ContainerNode containerNode = new ContainerNode(subNodes, new Point(x, 5));
        containerNode.setName(identifier);
        containerNode.setBorder(4);
        containerNode.setGradColors(Controller.GROUP_LIGHT_COLOR, Controller.GROUP_DARK_COLOR);
        containerNode.setMovable(moveable);
        containerNode.setIsCloseable(true);
        containerNode.addDefaultNodeFilter(releasedNode -> {
            boolean isAddable = false;
            if (releasedNode instanceof RoundedTextNode) {
                isAddable = containerNode.getElements().stream()
                        .filter(defaultNode -> defaultNode instanceof RoundedTextNode)
                        .map(node -> ((RoundedTextNode) node))
                        .map(RoundedTextNode::getText)
                        .noneMatch(name -> name.equals(((RoundedTextNode) releasedNode).getText()));
            }
            return isAddable;
        });

        targetPanel.addNode(containerNode);
        targetPanel.resize();
        return containerNode;
    }

    /**
     * getter
     * @return
     */
    public ArrayList<FpPanel> getFilterPanelList() {
        return filterPanelList;
    }

    /**
     * getter
     * @return
     */
    public ArrayList<TreeView<XmlElementTreeItem>> getTreeViewPanelList() {
        return treeViewPanelList;
    }

    public TreeView<XmlElementTreeItem> getTreeViewForUuid(String uuid) {
        for (TreeView<XmlElementTreeItem> treeView : this.treeViewPanelList) {
            if(treeView.getRoot().getValue().getAttributeValueByName("ID").equals(uuid)) {
                return treeView;
            }
        }
        return null;
    }

    public TextField getTextFieldNameId() {
        return textFieldNameId;
    }

    public TextField getTextFieldAuthorId() {
        return textFieldAuthorId;
    }

    public TextField getTextFieldTagsId() {
        return textFieldTagsId;
    }

    public TextField getTextFieldDescriptionId() {
        return textFieldDescriptionId;
    }

    public void setStage(Stage stage) {
        this.stage = stage;
        stage.setOnCloseRequest(event -> {
            if(this.notSaved) {
                Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
                alert.setTitle("WARNING");
                alert.setHeaderText("Are you sure you want to exit?\n" +
                        "All Unsaved data will be lost.");
                alert.setContentText("Proceed with Close?");
                alert.getButtonTypes().remove(0);
                alert.getButtonTypes().add(0, new ButtonType("SAVE", ButtonBar.ButtonData.OK_DONE));
                alert.getButtonTypes().add(1, new ButtonType("CLOSE", ButtonBar.ButtonData.FINISH));

                Optional<ButtonType> result = alert.showAndWait();
                if (result.get() == ButtonType.CANCEL) {
                    event.consume();
                }
                else if(result.get().getText().equals("SAVE")) {
                    if(!saveAs()) {
                        event.consume();
                    }
                    else {
                        System.exit(0);
                    }
                } else {
                    System.exit(0);
                }
            }
            else {
                System.exit(0);
            }
        });
    }

    @FXML
    public void closeWindow() {
        this.stage.fireEvent(new WindowEvent(this.stage, WindowEvent.WINDOW_CLOSE_REQUEST));
    }

    public void addNewFilterGroup(ActionEvent actionEvent) {
        this.addNewFilterGroup();
    }

    public void saveAs(ActionEvent actionEvent) {
        this.saveAs();
    }
}
