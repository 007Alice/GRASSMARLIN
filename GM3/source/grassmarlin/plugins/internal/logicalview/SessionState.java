package grassmarlin.plugins.internal.logicalview;

import com.sun.javafx.collections.ObservableListWrapper;
import grassmarlin.Logger;
import grassmarlin.plugins.internal.logicalview.visual.*;
import grassmarlin.plugins.internal.logicalview.visual.filters.EdgeStyleRule;
import grassmarlin.plugins.internal.logicalview.visual.filters.Style;
import grassmarlin.session.LogicalVertex;
import grassmarlin.session.Property;
import grassmarlin.session.Session;
import grassmarlin.session.pipeline.ILogicalPacketMetadata;
import grassmarlin.session.serialization.Loader;
import grassmarlin.session.serialization.Writer;
import grassmarlin.session.serialization.XmlSerializable;
import grassmarlin.ui.common.ImageDirectoryWatcher;
import grassmarlin.ui.common.SessionInterfaceController;
import grassmarlin.ui.common.dialogs.details.PropertyContainerDetailsDialog;
import grassmarlin.ui.common.menu.ActiveMenuItem;
import grassmarlin.ui.common.menu.DynamicSubMenu;
import grassmarlin.ui.common.menu.SliderMenuItem;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TreeItem;

import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/* Fun fact: The first draft of this code was generated by taking all the photos of
  Scrabble boards from the team's game night, feeding them into an algorithm that
  attempted to stitch them together, then running the resulting image through OCR.
  At least, that is the conclusion that was drawn at the start of the last
  refactoring effort.  We don't have to worry about that happening again; we took
  Scrabble out of our rotation. */
public class SessionState implements XmlSerializable {
    private final DialogPacketList dlgPacketList = new DialogPacketList();
    private final PropertyContainerDetailsDialog dlgDetails = new PropertyContainerDetailsDialog();

    protected class ViewPrimarySwing extends ViewLogical<SessionConnectedLogicalGraph, grassmarlin.plugins.internal.logicalview.swing.LogicalVisualization> {
        protected ViewPrimarySwing(final LogicalNavigation navigation) {
            super(SessionState.this,
                    SessionState.this.graph,
                    new ReadOnlyStringWrapper("Logical Graph - Swing Beta"),
                    view -> new grassmarlin.plugins.internal.logicalview.swing.LogicalVisualization(view),
                    navigation,
                    false);
        }
    }

    protected class ViewPrimary extends ViewLogical<SessionConnectedLogicalGraph, LogicalVisualization> {
        protected ViewPrimary(final LogicalNavigation navigation) {
            super(SessionState.this,
                    SessionState.this.graph,
                    new ReadOnlyStringWrapper("Logical Graph"),
                    view -> new ForceDirectedLayoutLogicalVisualization(view),
                    navigation,
                    false);
        }

        @Override
        protected List<MenuItem> getVertexContextMenuItems(final GraphLogicalVertex vertex, final LogicalVertex row) {
            final List<MenuItem> result = super.getVertexContextMenuItems(vertex, row);

            //Watch and filter views can only be created from the primary view.
            //This is a UX restriction; the ability to close filter and watch windows means that a
            // watch of a filter of the root graph could be created and the filter view closed.  This
            // would complicate serialization and remove the ability to change the filters.
            // Eventually it would be nice to support this, but the usability concerns have to be
            // addressed.
            //Filter Views are created from the common menu since they don't require a vertex as context.
            result.add(
                new ActiveMenuItem("Create Watch View...", event -> {
                    final SessionState.ViewWatch view = ViewPrimary.this.sessionState.createWatchView(ViewPrimary.this.graph, ViewPrimary.this.visualization, vertex, 2);
                    ViewPrimary.this.sessionState.views.put(ViewPrimary.this.sessionState.genId(), view);
                    ViewPrimary.this.sessionState.controller.createView(view, true);
                })
            );
            return result;
        }
        @Override
        protected List<MenuItem> getCommonContextMenuItems() {
            final List<MenuItem> result = new ArrayList<>(super.getCommonContextMenuItems());
            result.add(
                    new ActiveMenuItem("Create Filter View...", event -> {
                        final SessionState.ViewFilter view = ViewPrimary.this.sessionState.createFilterView(ViewPrimary.this.graph);
                        ViewPrimary.this.sessionState.views.put(ViewPrimary.this.sessionState.genId(), view);
                        ViewPrimary.this.sessionState.controller.createView(view, true);
                    })
            );
            return result;
        }
    }

    protected class ViewWatch extends ViewLogical<WatchFilteredLogicalGraph, MirrorLayoutLogicalVisualization> {
        private final GraphLogicalVertex root;
        private final IntegerProperty degree;

        private final SliderMenuItem miSelectDegree;

        protected ViewWatch(final WatchFilteredLogicalGraph graph, final LogicalVisualization baseVisualization, final LogicalNavigation navigation, final GraphLogicalVertex root, final IntegerProperty degree) {
            super(
                    SessionState.this,
                    graph,
                    new ReadOnlyStringWrapper("Logical Graph: Watch - " + root.toString() + " (").concat(degree).concat(")"),
                    view -> new MirrorLayoutLogicalVisualization(view, baseVisualization),
                    navigation,
                    true
            );

            this.root = root;
            this.degree = degree;

            // == Build menu item to select degree
            this.miSelectDegree = new SliderMenuItem("Degrees", "", this.degree, 1, 10, this.visualization);

            this.degree.addListener(observable -> {
                SessionState.this.markSessionAsModified();
            });

        }

        @Override
        protected List<MenuItem> getCommonContextMenuItems() {
            final ArrayList<MenuItem> resultFromParent = new ArrayList<>(super.getCommonContextMenuItems());

            resultFromParent.add(this.miSelectDegree);

            return resultFromParent;
        }
    }
    protected class ViewFilter extends ViewLogical<BlacklistFilteredLogicalGraph, MirrorLayoutLogicalVisualization> {
        private final List<GraphLogicalVertex> blacklist;

        public ViewFilter(final BlacklistFilteredLogicalGraph graph, final LogicalVisualization visualizationRoot) {
            super(
                    SessionState.this,
                    graph,
                    new ReadOnlyStringWrapper("Logical Graph: Filter View"),
                    view -> new MirrorLayoutLogicalVisualization(view, visualizationRoot),
                    new LogicalNavigation(graph),
                    true
            );

            this.blacklist = graph.getHiddenVertices();
        }

        @Override
        protected List<MenuItem> getCommonContextMenuItems() {
            final List<MenuItem> result = new ArrayList<>(super.getCommonContextMenuItems());
            result.add(new DynamicSubMenu("Unhide", null, () ->
                ViewFilter.this.graph.getHiddenVertices().stream()
                        .map(vertex -> new ActiveMenuItem(vertex.toString(), event -> {
                            ViewFilter.this.graph.unhideVertex(vertex);
                        })).collect(Collectors.toList())
            ));
            return result;
        }

        @Override
        protected List<MenuItem> getVertexContextMenuItems(final GraphLogicalVertex vertex, final LogicalVertex row) {
            final List<MenuItem> result = new ArrayList<>(super.getVertexContextMenuItems(vertex, row));
            result.add(new ActiveMenuItem("Hide", event -> {
                ViewFilter.this.graph.hideVertex(vertex);
            }));
            return result;
        }
    }

    protected class ViewReports extends SessionInterfaceController.View {
        protected ViewReports(final Node content, final TreeItem<Object> root) {
            super(
                    new ReadOnlyStringWrapper("Logical Graph: Reports"),
                    content,
                    root,
                    null,
                    null,
                    true,
                    false
            );
        }
    }

    private final Session session;
    private final SessionInterfaceController controller;
    private final Plugin plugin;

    private final ObservableList<Style> edgeStyles;
    private final ObservableList<EdgeStyleRule> edgeRules;
    private final Map<String, SessionInterfaceController.View> views;
    private final SessionConnectedLogicalGraph graph;

    public SessionState(final Session session, final SessionInterfaceController controller, final Plugin plugin) {
        this.session = session;
        this.controller = controller;
        this.plugin = plugin;

        //The order of views matters--the first one to be processed during loading has to be the root (session-connected) graph.
        this.views = new LinkedHashMap<>();

        this.edgeStyles = new ObservableListWrapper<>(new ArrayList<>());
        this.edgeRules = new ObservableListWrapper<>(new ArrayList<>());

        // TODO: Evaluate if the race condition that required the waitForValid() call still exists. (it was related to loading)
        this.graph = new SessionConnectedLogicalGraph(session, controller);

        final SessionInterfaceController.View viewPrimary = createPrimaryView();
        final SessionInterfaceController.View viewReports = createReportView();
        this.views.put("Primary", viewPrimary);
        this.views.put("Reports", viewReports);
        this.controller.createView(viewPrimary, true);
        this.controller.createView(viewReports, false);

        // The Swing view was created to present an alternative to JavaFX that, in theory, reduces the overhead of drawing and improves performance.
        // It was notably worse, even before it was as feature-rich as the JavaFX UI, and was therefore removed.
        // Development has stopped, but it is left here, should the need to use it arise in the future.
        // Even with worse (processor) performance, it likely is lighter on memory than the javafx implementation, so there may be merit in using it under the right circumstances.
        //final SessionInterfaceController.View viewSwing = createPrimaryViewSwing();
        //this.views.put("Primary_Swing", viewSwing);
        //this.controller.createView(viewSwing, true);
    }

    public Collection<Map.Entry<String, SessionInterfaceController.View>> getViews() {
        return this.views.entrySet();
    }

    public ViewPrimary getPrimaryView() {
        return (ViewPrimary)this.views.get("Primary");
    }

    protected ViewPrimary createPrimaryView() {
        //final LogicalVisualization visualization = new LogicalVisualization(this.graph, this);
        final LogicalNavigation navigation = new LogicalNavigation(this.graph);
        //TODO: the navigation and visualization need to be propertly intertwined.

        return new ViewPrimary(navigation);
    }
    protected ViewPrimarySwing createPrimaryViewSwing() {
        final LogicalNavigation navigation = new LogicalNavigation(this.graph);
        return new ViewPrimarySwing(navigation);
    }

    protected ViewReports createReportView() {
        final Reports reports = new Reports(this.graph);

        return new ViewReports(reports, reports.getTreeRoot());
    }

    protected ViewWatch createWatchView(final LogicalGraph base, final LogicalVisualization baseVisualization, final GraphLogicalVertex vertex, final int degreeInitial) {
        final SimpleIntegerProperty degreeProperty = new SimpleIntegerProperty(degreeInitial);

        final WatchFilteredLogicalGraph graphWatch = new WatchFilteredLogicalGraph(base, vertex, degreeProperty);
        final LogicalNavigation navigation = new LogicalNavigation(graphWatch);

        return new ViewWatch(graphWatch, baseVisualization, navigation, vertex, degreeProperty);
    }

    protected ViewFilter createFilterView(final LogicalGraph base) {
        final BlacklistFilteredLogicalGraph graph = new BlacklistFilteredLogicalGraph(base);
        return new ViewFilter(graph, this.getPrimaryView().visualization);
    }

    public ImageDirectoryWatcher getImageDirectoryWatcher() {
        return this.plugin.imageMapper;
    }
    //TODO: The members of Plugin that are used should be exposed here, but not the full plugin
    @Deprecated
    public Plugin getPlugin() {
        return this.plugin;
    }

    public void markSessionAsModified() {
        this.session.markAsModified();
    }

    private final AtomicInteger viewCounter = new AtomicInteger(0);
    protected String genId() {
        return "View" + Integer.toString(this.viewCounter.getAndIncrement());
    }

    public void showDetailsDialogFor(final GraphLogicalVertex container) {
        this.dlgDetails.targetProperty().set(container.getProperties());
        this.dlgDetails.setTitle("Details for " + container.getRootLogicalAddressMapping());
        this.dlgDetails.showAndWait();
    }
    public void showDetailsDialogFor(final GraphLogicalEdge container) {
        this.dlgDetails.targetProperty().set(container.getProperties());
        this.dlgDetails.setTitle("Details for " + container.getSource().getVertex().getLogicalAddressMapping() + " to " + container.getDestination().getVertex().getLogicalAddressMapping());
        this.dlgDetails.showAndWait();
    }
    public void showPacketListDialogFor(final LogicalGraph graph, final GraphLogicalVertex vertex) {
        this.dlgPacketList.setContent(graph, vertex);
        this.dlgPacketList.showAndWait();
    }
    public List<MenuItem> getPluginDefinedMenuItemsFor(final GraphLogicalVertex vertex, final LogicalVertex row) {
        return this.plugin.getMenuItemsFor(this.session, vertex, row);
    }
    public void recordPacket(final ILogicalPacketMetadata packet) {
        this.graph.recordPacket(packet);
    }

    public ObservableList<Style> getEdgeStyles() {
        return this.edgeStyles;
    }
    public ObservableList<EdgeStyleRule> getEdgeRules() {
        return this.edgeRules;
    }

    // == Serialization

    @Override
    public void readFromXml(XMLStreamReader source) throws XMLStreamException {
        final String elementTerminal = source.getLocalName();

        this.viewCounter.set(Integer.parseInt(source.getAttributeValue(null, "NextId")));

        while(source.hasNext()) {
            switch (source.nextTag()) {
                case XMLStreamReader.START_ELEMENT:
                    if (source.getLocalName().equals("View")) {
                        switch (source.getAttributeValue(null, "Type")) {
                            case "Primary":
                                //We don't have to create the primary (session connected) graph, it will already exist.
                                //We do, however, have to wait for all the events to fire to ensure that the key lookups will work.
                                this.graph.waitForValid();
                                break;
                            case "Watch": {
                                final String name = source.getAttributeValue(null, "Name");
                                final String keyRoot = source.getAttributeValue(null, "WatchRoot");
                                final int degree = Integer.parseInt(source.getAttributeValue(null, "WatchDegree"));

                                final ViewWatch view = createWatchView(this.graph, this.getPrimaryView().visualization, this.graph.vertexForKey(keyRoot), degree);
                                this.views.put(name, view);
                                this.controller.createView(view, true);
                                } break;
                            case "Blacklist": {
                                final String name = source.getAttributeValue(null, "Name");
                                final ViewFilter view = createFilterView(this.graph);

                                this.readBlacklistFromXml(source, view);

                                this.views.put(name, view);
                                this.controller.createView(view, true);
                                } break;
                            default:
                                Logger.log(Logger.Severity.WARNING, "Unable to restore Logical Graph View of type %s", source.getAttributeValue(null, "Type"));
                                break;
                        }
                    } else if (source.getLocalName().equals("GraphLogicalVertex")) {
                        final String key = source.getAttributeValue(null, "Key");
                        this.graph.vertexForKey(key).readFromXml(source);
                    } else if (source.getLocalName().equals("Edge")) {
                        final String key = source.getAttributeValue(null, "Key");
                        this.graph.edgeForKey(key).readFromXml(source);
                    } else if (source.getLocalName().equals("EdgeStyle")) {
                        this.edgeStyles.add(new Style(source));
                    } else if (source.getLocalName().equals("EdgeStyleRule")) {
                        final String nameStyle = source.getAttributeValue(null, "Style");
                        final Object rule = Loader.readObject(source);
                        if(rule instanceof EdgeStyleRule) {
                            ((EdgeStyleRule)rule).styleProperty().set(this.edgeStyles.stream().filter(style -> style.getName().equals(nameStyle)).findAny().orElse(null));
                            this.edgeRules.add((EdgeStyleRule)rule);
                        }
                    } else if (source.getLocalName().equals("Graph")) {
                        //We don't do anything with this, but it shouldn't produce a warning, either.
                    } else {
                        //Don't know what to do with it.
                        Logger.log(Logger.Severity.WARNING, "Unexpected element reading Logical Graph: %s", source.getLocalName());
                    }
                    break;
                case XMLStreamReader.END_ELEMENT:
                    if (source.getLocalName().equals(elementTerminal)) {
                        return;
                    }
                    break;
                case XMLStreamReader.END_DOCUMENT:
                    return;
            }
        }
    }

    private void readBlacklistFromXml(final XMLStreamReader source, final ViewFilter view) throws XMLStreamException {
        final String elementTerminal = source.getLocalName();

        while(source.hasNext()) {
            switch(source.nextTag()) {
                case XMLStreamReader.START_ELEMENT:
                    if(source.getLocalName().equals("Exclude")) {
                        view.graph.hideVertex(this.graph.vertexForKey(source.getAttributeValue(null, "Key")));
                    }
                    break;
                case XMLStreamReader.END_ELEMENT:
                    if(source.getLocalName().equals(elementTerminal)) {
                        return;
                    }
                    break;
                case XMLStreamReader.END_DOCUMENT:
                    return;
            }
        }
    }

    @Override
    public void writeToXml(XMLStreamWriter target) throws XMLStreamException {
        target.writeAttribute("NextId", Integer.toString(this.viewCounter.get()));

        for(Map.Entry<String, SessionInterfaceController.View> entry : this.views.entrySet()) {
            //The Reports tab doesn't need to be saved--we only need visualizations and all of them are derived from ViewLogical
            if(!(entry.getValue() instanceof ViewLogical)) {
                continue;
            }

            target.writeStartElement("View");

            target.writeAttribute("Name", entry.getKey());
            if(entry.getValue() instanceof ViewPrimary) {
                target.writeAttribute("Type", "Primary");
            } else if(entry.getValue() instanceof ViewWatch) {
                target.writeAttribute("Type", "Watch");
                target.writeAttribute("WatchRoot", ((ViewWatch)entry.getValue()).root.getKey());
                target.writeAttribute("WatchDegree", Integer.toString(((ViewWatch)entry.getValue()).degree.get()));
            } else if(entry.getValue() instanceof ViewFilter) {
                target.writeAttribute("Type", "Blacklist");
                for(GraphLogicalVertex vertexExcluded : ((ViewFilter)entry.getValue()).blacklist) {
                    target.writeStartElement("Exclude");
                    target.writeAttribute("Key", vertexExcluded.getKey());
                    target.writeEndElement();
                }
            } else {
                target.writeAttribute("Type", "Unknown");
                //TODO: This is actually a pretty serious failure situation.
            }

            target.writeEndElement();
        }

        //We write details for the session-connected graph here.  Every other graph will be derived from that one, sharing the same objects, so we only need to write the details once.
        target.writeStartElement("Graph");
        final ArrayList<GraphLogicalVertex> vertices = new ArrayList<>();
        final ArrayList<GraphLogicalEdge> edges = new ArrayList<>();
        this.graph.getAtomic(vertices, edges);

        //For each vertex we need to know what properties were defined at the GraphLogicalVertex level.
        for(final GraphLogicalVertex vertex : vertices) {
            final Map<String, Map<String, Set<Property<?>>>> properties = vertex.getProvidedProperties();
            //If there are any properties in any of the sets, we have to save the state.
            if(properties.values().stream().flatMap(map -> map.values().stream()).flatMap(Set::stream).findAny().isPresent()) {
                target.writeStartElement("GraphLogicalVertex");
                target.writeAttribute("Key", vertex.getKey());

                vertex.writeToXml(target);

                target.writeEndElement();
            }
        }
        for(final GraphLogicalEdge edge : edges) {
            target.writeStartElement("Edge");
            target.writeAttribute("Key", edge.getKey());

            edge.writeToXml(target);

            target.writeEndElement();
        }
        for(final Style style : this.edgeStyles) {
            target.writeStartElement("EdgeStyle");
            style.writeToXml(target);
            target.writeEndElement();
        }
        for(final EdgeStyleRule rule : this.edgeRules) {
            target.writeStartElement("EdgeStyleRule");
            target.writeAttribute("Style", rule.styleProperty().get().getName());
            Writer.writeObject(target, rule);
            target.writeEndElement();
        }

        target.writeEndElement();
    }
}
