package core.exportdata;

import core.Core;
import core.ViewUtils;
import core.dataexport.*;
import core.topology.Mac;
import core.types.ByteTreeItem;
import core.types.LogEmitter;
import org.apache.commons.lang3.time.DateFormatUtils;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.namespace.QName;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.util.*;
import java.util.function.Consumer;

/**
 * Exports data to a file
 * 
 * 2015.08.26 - CC - New...
 * 2015.09.24 - BESTDOG - Added {@link #afterSave} to support export-share.
 */
public class DataExporter {
    /** the generated xml type */
    private GmDataExportType dataExport;
    /** marshals the java classes to xml */
    private Marshaller dataExportMarshaller;
    /** creates all the java objects generated by the xsd */
    private ObjectFactory dataExportObjectFactory;
    
    /**
     * Context singleton for marshaling
     */
    public enum DataExportContext {
        INSTANCE("core.dataexport");

        private JAXBContext context;

        DataExportContext(String classToCreate) {
            try {
                this.context = JAXBContext.newInstance(classToCreate);
            } catch (JAXBException e) {
                throw new IllegalStateException("unable to create JAXBContext");
            }
        }
        public JAXBContext getContext(){
            return context;
        }
    }

    /**
     * Constructs a new DataExporter it is recommended you create a new data export class instance each time you are exporting data
     */
    public DataExporter() {
        this.dataExportObjectFactory = new ObjectFactory();
        this.dataExport = this.dataExportObjectFactory.createGmDataExportType();
        this.dataExport.setData(this.dataExportObjectFactory.createDataType());
        this.dataExport.setFingerprints(this.dataExportObjectFactory.createFingerprintsType());
        this.dataExport.setImportedItems(this.dataExportObjectFactory.createImportedItemsType());
    }

    /**
     * Constructs a new DataExporter that will call the {@link #afterSave} callback upon writing out the file.
     * @param afterSave See {@link #afterSave}.
     */
    public DataExporter(Consumer<File> afterSave) {
        this();
    }
    
    /**
     * After all the data has been set call this to save the xml to the file
     * 
     * @param saveFile file to save
     * @throws IOException
     * @throws JAXBException
     */
    public void saveFile(File saveFile) throws IOException, JAXBException {
        if(this.dataExportMarshaller == null) {
            this.dataExportMarshaller = DataExportContext.INSTANCE.getContext().createMarshaller();
            this.dataExportMarshaller.setProperty("jaxb.formatted.output", true);
        }

        try (FileOutputStream out = new FileOutputStream(saveFile)) {
            JAXBElement<GmDataExportType> element = new JAXBElement<>(new QName("", "GmDataExportType"), GmDataExportType.class, this.dataExport);
            this.dataExportMarshaller.marshal(element, out);
        }
 
    }




    /**
     * Exports a given devices info, if this device belongs to a new network will also add that network
     * @param networkName attribute
     * @param name attribute
     * @param primaryAddress attribute
     * @param connectionMap attribute
     * @param detailMap attribute
     */
    public void exportDevice(String networkName, String name, String primaryAddress, HashMap<String, String> detailMap, NodeType nodeType, HashMap<String, String> connectionMap, ByteTreeItem byteTreeItem) {
        HashMap<String,ConnectionType> connectionIpToConnectionObjectMap = new HashMap<>();
        DeviceType deviceType = this.dataExportObjectFactory.createDeviceType();
        deviceType.setName(name);
        deviceType.setType(nodeType);
        deviceType.setPrimaryAddress(primaryAddress);
        detailMap.keySet().stream().forEach(key -> {
            DetailType detail = this.dataExportObjectFactory.createDetailType();
            detail.setName(key);
            detail.setValue(detailMap.get(key));
            deviceType.getDetail().add(detail);
        });
        connectionMap.keySet().stream().forEach(key -> {
            ConnectionType connection = this.dataExportObjectFactory.createConnectionType();
            connection.setIp(key);
            connection.setValue(connectionMap.get(key));
            connectionIpToConnectionObjectMap.put(key, connection);
            deviceType.getConnection().add(connection);
        });
        boolean[] isNewNetwork = {true};
        this.dataExport.getData().getNetwork().stream()
                .filter(networkType1 -> networkType1.getName().equals(networkName)).forEach(networkType -> {
            networkType.getDevice().add(deviceType);
            isNewNetwork[0] = false;
        });
        if(isNewNetwork[0]) {
            NetworkType network = this.dataExportObjectFactory.createNetworkType();
            network.setName(networkName);
            network.getDevice().add(deviceType);
            this.dataExport.getData().getNetwork().add(network);
        }
        pupulateConnectionTypesWithByteData(connectionIpToConnectionObjectMap, byteTreeItem);
    }

    private void pupulateConnectionTypesWithByteData(HashMap<String, ConnectionType> connectionIpToConnectionObjectMap, ByteTreeItem byteTreeItem) {
        byteTreeItem.edges.forEach((destinationHostIp, protocols) -> {
            String destinationIp = ViewUtils.ipString(destinationHostIp);
            protocols.forEach((protocol, sources) -> {
                sources.forEach((source, destinations) -> {
                    destinations.forEach((destination, data) -> {
                        data.right.forEach(frameInformation -> {
                            if (connectionIpToConnectionObjectMap.containsKey(destinationIp) && frameInformation != null) {
                                ConnectionType connectionType = connectionIpToConnectionObjectMap.get(destinationIp);
                                connectionType.setProtocol(new BigInteger(protocol.toString()));
                                connectionType.setSrcPort(new BigInteger(source.toString()));
                                connectionType.setDstPort(new BigInteger(destination.toString()));
                                connectionType.setFrameNumber(frameInformation.packet);
                                connectionType.setSize(new BigInteger(frameInformation.size.toString()));
                                connectionType.setTimestamp(frameInformation.date);
                                connectionType.setSrcMac(Mac.toString(byteTreeItem.MAC));
                                connectionType.setDstMac(Mac.toString(destinationHostIp.MAC));
                            }
                            if (frameInformation == null) {
                                LogEmitter.factory.get().emit(this, Core.ALERT.WARNING, "frameInformation is null " + destinationIp);
                            }
                        });
                    });
                });
            });
        });

        // all inbound connections to this treeViewNode
        if(byteTreeItem.backEdges != null) {
            byteTreeItem.backEdges.stream().forEach(peer -> { // a peer has an inbound connection to this treeViewNode
                String sourceIp = ViewUtils.ipString(peer);
                peer.edges.get(byteTreeItem).forEach((protocol, sources) ->
                                sources.forEach((source, destinations) ->
                                                destinations.forEach((destination, data) ->
                                                                data.right.forEach(frameInformation -> {
                                                                    if (connectionIpToConnectionObjectMap.containsKey(sourceIp) && frameInformation != null) {
                                                                        ConnectionType connectionType = connectionIpToConnectionObjectMap.get(sourceIp);
                                                                        connectionType.setProtocol(new BigInteger(protocol.toString()));
                                                                        connectionType.setSrcPort(new BigInteger(source.toString()));
                                                                        connectionType.setDstPort(new BigInteger(destination.toString()));
                                                                        connectionType.setFrameNumber(frameInformation.packet);
                                                                        connectionType.setSize(new BigInteger(frameInformation.size.toString()));
                                                                        connectionType.setTimestamp(frameInformation.date);
                                                                        connectionType.setSrcMac(Mac.toString(byteTreeItem.MAC));
                                                                        connectionType.setDstMac(Mac.toString(peer.MAC));
                                                                    }
                                                                    if (frameInformation == null) {
                                                                        LogEmitter.factory.get().emit(this, Core.ALERT.WARNING, "frameInformation is null " + sourceIp);
                                                                    }
                                                                })
                                                )
                                )
                );
            });
        }
    }

    /**
     * adds the fingerprint files to the export file
     * @param fingerprintFiles
     */
    public void exportFingerprintFiles(Set<File> fingerprintFiles) {
        fingerprintFiles.stream().map(File::getAbsolutePath).map(this::makeFileType).forEach(filePath -> this.dataExport.getFingerprints().getFingerprint().add(filePath));
    }

    /**
     * exports a list of paths to fingerprints
     * @param paths paths to loaded fingerprints
     */
    public void exportFingerprintPaths(List<String> paths) {
        paths.stream().map(this::makeFileType).forEach(filePath -> this.dataExport.getFingerprints().getFingerprint().add(filePath));
    }

    /**
     * exports a list of imported files' paths
     * @param paths to imported files
     */
    public void exportImportedFilePaths(List<String> paths) {
        paths.stream().map(this::makeFileType).forEach(filePath -> this.dataExport.getImportedItems().getImportedItem().add(filePath));
    }

    /**
     * translates a file path into a fileType obeject
     * @param path to the file
     * @return FileType object
     */
    private FileType makeFileType(String path) {
        FileType fileType = this.dataExportObjectFactory.createFileType();
        fileType.setPath(path);
        return fileType;
    }
}
